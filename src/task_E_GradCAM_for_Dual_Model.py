# -*- coding: utf-8 -*-
"""Dual1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1g89uRy6QGHOMpGoojoYRq8iTlKC0Pfwu
"""

import copy
import os
import random
import sys
import numpy as np
import pandas as pd
import torch
import torch.nn as nn
from PIL import Image
from torchvision import models, transforms
import matplotlib.pyplot as plt
import cv2

torch.cuda.empty_cache()

class MyModel(nn.Module):
    def __init__(self, num_classes=5, dropout_rate=0.62):
        super().__init__()

        self.backbone = models.resnet34(pretrained=True)
        self.backbone.fc = nn.Identity()

        self.fc = nn.Sequential(
            nn.Linear(512, 256),
            nn.ReLU(inplace=True),
            nn.Dropout(p=dropout_rate),
            nn.Linear(256, 128),
            nn.ReLU(inplace=True),
            nn.Dropout(p=dropout_rate),
            nn.Linear(128, num_classes)
        )

    def forward(self, x):
        x = self.backbone(x)
        x = self.fc(x)
        return x

class MyDualModel(nn.Module):
    def __init__(self, num_classes=5, dropout_rate=0.62):
        super().__init__()

        backbone = models.resnet34(pretrained=True)
        backbone.fc = nn.Identity()

        self.backbone1 = copy.deepcopy(backbone)
        self.backbone2 = copy.deepcopy(backbone)

        for param in self.backbone1.parameters():
            param.requires_grad = True
        for param in self.backbone2.parameters():
            param.requires_grad = True

        self.fc = nn.Sequential(
            nn.Linear(512 * 2, 256),
            nn.ReLU(inplace=True),
            nn.Dropout(p=dropout_rate),
            nn.Linear(256, 128),
            nn.ReLU(inplace=True),
            nn.Dropout(p=dropout_rate),
            nn.Linear(128, num_classes)
        )

    def forward(self, images):
        image1, image2 = images

        x1 = self.backbone1(image1)
        x2 = self.backbone2(image2)

        x = torch.cat((x1, x2), dim=1)
        x = self.fc(x)
        return x

from google.colab import drive
drive.mount('/content/drive/')

class GradCAMDual:
    def __init__(self, model, target_layer1, target_layer2):
        self.model = model
        self.target_layer1 = target_layer1
        self.target_layer2 = target_layer2

        self.gradients1 = None
        self.activations1 = None
        self.gradients2 = None
        self.activations2 = None

        self._register_hooks()

    def _register_hooks(self):
        def forward_hook1(module, input, output):
            self.activations1 = output

        def forward_hook2(module, input, output):
            self.activations2 = output

        self.target_layer1.register_forward_hook(forward_hook1)
        self.target_layer2.register_forward_hook(forward_hook2)

    def generate(self, input_tensor1, input_tensor2, class_idx):
        self.model.eval()
        self.model.zero_grad()

        output = self.model((input_tensor1, input_tensor2))

        target = output[:, class_idx]

        self.model.zero_grad()
        target.backward(retain_graph=True)

        gradients1 = torch.autograd.grad(target, self.target_layer1.parameters(), retain_graph=True)[0]
        activations1 = self.activations1.detach().cpu().numpy()[0]
        gradients1 = gradients1.detach().cpu().numpy()[0]

        weights1 = gradients1.mean(axis=(1, 2))
        cam1 = (weights1[:, None, None] * activations1).sum(axis=0)
        cam1 = np.maximum(cam1, 0)
        cam1 -= np.min(cam1)
        cam1 /= (cam1.max() + 1e-7)

        gradients2 = torch.autograd.grad(target, self.target_layer2.parameters(), retain_graph=True)[0]
        activations2 = self.activations2.detach().cpu().numpy()[0]
        gradients2 = gradients2.detach().cpu().numpy()[0]

        weights2 = gradients2.mean(axis=(1, 2))
        cam2 = (weights2[:, None, None] * activations2).sum(axis=0)
        cam2 = np.maximum(cam2, 0)
        cam2 -= np.min(cam2)
        cam2 /= (cam2.max() + 1e-7)

        return cam1, cam2

model_path = '/content/drive/MyDrive/ColabNotebooks/model_dual.pth'  #model is in mounted google drive. When you run the code change the path accordingly
# Load the dual model
dual_model = MyDualModel()
dual_model.load_state_dict(torch.load(model_path, map_location=torch.device('cpu')))
dual_model.eval()

# Define two test images
i = 496 #347-500
img_path1 = f'/content/drive/MyDrive/ColabNotebooks/DeepDRiD/test/{i}/{i}_r1.jpg' #images of the same eye
img_path2 = f'/content/drive/MyDrive/ColabNotebooks/DeepDRiD/test/{i}/{i}_r2.jpg'

transform_test = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

image1 = Image.open(img_path1).convert('RGB')
image2 = Image.open(img_path2).convert('RGB')

input_tensor1 = transform_test(image1).unsqueeze(0)
input_tensor2 = transform_test(image2).unsqueeze(0)

target_layer1 = dual_model.backbone1.layer4[-1]
target_layer2 = dual_model.backbone2.layer4[-1]  # Last block of layer4 in backbone2

grad_cam_dual = GradCAMDual(dual_model, target_layer1, target_layer2)

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
input_tensor1 = input_tensor1.to(device)
input_tensor2 = input_tensor2.to(device)
dual_model = dual_model.to(device)

cam1, cam2 = grad_cam_dual.generate(input_tensor1, input_tensor2, class_idx=3)

def denormalize(tensor, mean, std):
    tensor = tensor.clone()
    for t, m, s in zip(tensor, mean, std):
        t.mul_(s).add_(m)
    return tensor

original_img1 = denormalize(input_tensor1.squeeze(), mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
original_img1 = transforms.ToPILImage()(original_img1)

original_img2 = denormalize(input_tensor2.squeeze(), mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
original_img2 = transforms.ToPILImage()(original_img2)

heatmap1 = cv2.applyColorMap(np.uint8(255 * cam1), cv2.COLORMAP_JET)
heatmap2 = cv2.applyColorMap(np.uint8(255 * cam2), cv2.COLORMAP_JET)

heatmap1 = np.float32(heatmap1)[..., ::-1]
heatmap2 = np.float32(heatmap2)[..., ::-1]

heatmap1_resized = cv2.resize(heatmap1, (original_img1.size[0], original_img1.size[1]))
heatmap2_resized = cv2.resize(heatmap2, (original_img2.size[0], original_img2.size[1]))

overlayed_img1 = 0.5 * np.array(original_img1) + 0.5 * heatmap1_resized
overlayed_img2 = 0.5 * np.array(original_img2) + 0.5 * heatmap2_resized

# results
plt.figure(figsize=(12, 6))

plt.subplot(2, 3, 1)
plt.title('Original Image 1')
plt.imshow(original_img1)
plt.axis('off')

plt.subplot(2, 3, 2)
plt.title('Heatmap 1')
plt.imshow(heatmap1_resized.astype(np.uint8))
plt.axis('off')

plt.subplot(2, 3, 3)
plt.title('Grad-CAM 1')
plt.imshow(np.uint8(overlayed_img1))
plt.axis('off')

plt.subplot(2, 3, 4)
plt.title('Original Image 2')
plt.imshow(original_img2)
plt.axis('off')

plt.subplot(2, 3, 5)
plt.title('Heatmap 2')
plt.imshow(heatmap2_resized.astype(np.uint8))
plt.axis('off')

plt.subplot(2, 3, 6)
plt.title('Grad-CAM 2')
plt.imshow(np.uint8(overlayed_img2))
plt.axis('off')

plt.show()