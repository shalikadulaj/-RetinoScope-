# -*- coding: utf-8 -*-
"""Single4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15FCtGcFN_1LLuWBtCdkG2MT_2E5kkzXR
"""

import copy
import os
import random
import sys
import numpy as np
import pandas as pd
import torch
import torch.nn as nn
from PIL import Image
from torchvision import models, transforms
import matplotlib.pyplot as plt
import cv2

torch.cuda.empty_cache()

class MyModel(nn.Module):
    def __init__(self, num_classes=5, dropout_rate=0.62):
        super().__init__()

        self.backbone = models.resnet34(pretrained=True)
        self.backbone.fc = nn.Identity()

        self.fc = nn.Sequential(
            nn.Linear(512, 256),
            nn.ReLU(inplace=True),
            nn.Dropout(p=dropout_rate),
            nn.Linear(256, 128),
            nn.ReLU(inplace=True),
            nn.Dropout(p=dropout_rate),
            nn.Linear(128, num_classes)
        )

    def forward(self, x):
        x = self.backbone(x)
        x = self.fc(x)
        return x

class MyDualModel(nn.Module):
    def __init__(self, num_classes=5, dropout_rate=0.62):
        super().__init__()

        backbone = models.resnet34(pretrained=True)
        backbone.fc = nn.Identity()

        self.backbone1 = copy.deepcopy(backbone)
        self.backbone2 = copy.deepcopy(backbone)

        for param in self.backbone1.parameters():
            param.requires_grad = True
        for param in self.backbone2.parameters():
            param.requires_grad = True

        self.fc = nn.Sequential(
            nn.Linear(512 * 2, 256),
            nn.ReLU(inplace=True),
            nn.Dropout(p=dropout_rate),
            nn.Linear(256, 128),
            nn.ReLU(inplace=True),
            nn.Dropout(p=dropout_rate),
            nn.Linear(128, num_classes)
        )

    def forward(self, images):
        image1, image2 = images

        x1 = self.backbone1(image1)
        x2 = self.backbone2(image2)

        x = torch.cat((x1, x2), dim=1)
        x = self.fc(x)
        return x

from google.colab import drive
drive.mount('/content/drive/')

img_path = '/content/drive/MyDrive/ColabNotebooks/496_r2.jpg'
#img_path = '/content/drive/MyDrive/ColabNotebooks/390_r2.jpg'
#img_path = '/content/drive/MyDrive/ColabNotebooks/356_l1.jpg'
model_path = '/content/drive/MyDrive/ColabNotebooks/model_single.pth'

model = MyModel()
model.load_state_dict(torch.load(model_path, map_location=torch.device('cpu')))
model.eval()

transform_test = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

image = Image.open(img_path).convert('RGB')
input_tensor = transform_test(image).unsqueeze(0)

class GradCAM:
    def __init__(self, model, target_layer):
        self.model = model
        self.target_layer = target_layer
        self.gradients = None
        self.activations = None

        self._register_hooks()

    def _register_hooks(self):
        def forward_hook(module, input, output):
            self.activations = output

        self.target_layer.register_forward_hook(forward_hook)

    def generate(self, input_tensor, class_idx):
        output = self.model(input_tensor)

        target = output[:, class_idx]

        self.model.zero_grad()
        target.backward(retain_graph=True)

        gradients = torch.autograd.grad(target, self.target_layer.parameters(), retain_graph=True)[0]
        gradients = gradients.detach().cpu().numpy()[0]

        activations = self.activations.detach().cpu().numpy()[0]

        weights = gradients.mean(axis=(1, 2))

        cam = (weights[:, None, None] * activations).sum(axis=0)
        cam = np.maximum(cam, 0)

        cam -= np.min(cam)
        cam = cam / (cam.max()+ 1e-7)
        return cam

target_layer = model.backbone.layer4[-1]

grad_cam = GradCAM(model, target_layer)

input_tensor = input_tensor.to('cuda' if torch.cuda.is_available() else 'cpu')

cam = grad_cam.generate(input_tensor, class_idx=3)

def denormalize(tensor, mean, std):
    tensor = tensor.clone()
    for t, m, s in zip(tensor, mean, std):
        t.mul_(s).add_(m)
    return tensor


original_img = denormalize(input_tensor.squeeze(), mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
original_img = transforms.ToPILImage()(original_img)

heatmap = cv2.applyColorMap(np.uint8(255 * cam), cv2.COLORMAP_JET)
heatmap = np.float32(heatmap)
heatmap = heatmap[..., ::-1]

heatmap_resized = cv2.resize(heatmap, (original_img.size[0], original_img.size[1]))

overlayed_image = 0.5 * np.array(original_img) + 0.5 * heatmap_resized

plt.figure(figsize=(10, 5))
plt.subplot(1, 3, 1)
plt.title('Original Image')
plt.imshow(original_img)
plt.axis('off')

plt.subplot(1, 3, 2)
plt.title('Heat Map')
plt.imshow(heatmap)
plt.axis('off')

plt.subplot(1, 3, 3)
plt.title('Grad-CAM')
plt.imshow(np.uint8(overlayed_image))
plt.axis('off')

plt.show()